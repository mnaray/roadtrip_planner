name: Production Docker Image Build

# This workflow builds production-ready Docker images with semantic versioning
# 
# Workflow Order:
# 1. Build: Creates Docker image (untagged)
# 2. Test: Runs full test suite, security scans, and linting with PostgreSQL 17
# 3. Calculate Version: Determines semantic version (only after tests pass)
# 4. Push: Tags Docker image with version and pushes to Docker Hub
# 5. Tag: Creates git tag (only after successful push)
#
# Prerequisites:
# 1. Docker Hub Setup:
#    - Create Docker Hub account at https://hub.docker.com
#    - Create a repository (e.g., "roadtrip-planner")
#    - Note your full repository path: username/roadtrip-planner
#
# 2. GitHub Secrets (Settings ‚Üí Secrets and variables ‚Üí Actions ‚Üí Secrets):
#    - DOCKER_HUB_USERNAME: Your Docker Hub username (NOT email)
#    - DOCKER_HUB_TOKEN: Personal Access Token with Read, Write, Delete permissions
#      (Create at: Docker Hub ‚Üí Account Settings ‚Üí Security ‚Üí Access Tokens)
#
# 3. GitHub Variables (Settings ‚Üí Secrets and variables ‚Üí Actions ‚Üí Variables):
#    - DOCKER_HUB_REPOSITORY: Full Docker Hub path (e.g., "username/roadtrip-planner")
#      IMPORTANT: Must include your Docker Hub username prefix!
#      Without this, defaults to GitHub repo name which will likely fail
#
# Usage:
# - Manually trigger this workflow from GitHub Actions tab
# - Select version increment type: major, minor, or patch
# - Only successful builds and tests will get versioned and pushed
# - Git tags are only created after successful Docker push
#
# Troubleshooting:
# - "denied: requested access to the resource is denied" 
#   ‚Üí Check DOCKER_HUB_REPOSITORY includes username prefix
#   ‚Üí Verify repository exists on Docker Hub
#   ‚Üí Confirm token has correct permissions

on:
  workflow_dispatch:
    inputs:
      version_increment:
        description: 'Version increment type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
        default: 'patch'

permissions:
  contents: write  # Required for creating and pushing git tags
  actions: read    # Required for downloading artifacts
  
env:
  # Default Docker Hub repository name (can be overridden with repository variable)
  DOCKER_REPOSITORY: ${{ vars.DOCKER_HUB_REPOSITORY || github.event.repository.name }}

jobs:
  # Job 1: Build Docker image (without tags initially)
  build:
    runs-on: ubuntu-latest
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build production Docker image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: false  # Don't push yet, just build and store
          tags: roadtrip-planner:build-candidate
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=docker,dest=/tmp/docker-image-untagged.tar

      - name: Upload Docker image as artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-candidate
          path: /tmp/docker-image-untagged.tar
          retention-days: 7

      - name: Build summary
        run: |
          echo "üî® Docker image built successfully!"
          echo "üì∏ Image stored as artifact for testing"

  # Job 2: Run all tests using the built Docker image
  test:
    needs: build
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:17
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: roadtrip_planner_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Set up Ruby for testing
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: .ruby-version
          bundler-cache: true

      - name: Prepare test database
        env:
          RAILS_ENV: test
          DATABASE_URL: postgres://postgres:postgres@localhost:5432/roadtrip_planner_test
          PGHOST: localhost
          PGPORT: 5432
          PGUSER: postgres
          PGPASSWORD: postgres
          PGDATABASE: roadtrip_planner_test
        run: |
          bundle exec rails db:schema:load
          bundle exec rails db:test:prepare

      - name: Run security scans
        run: |
          echo "Running security scans..."
          bin/brakeman --no-pager
          bin/importmap audit

      - name: Run code quality checks
        run: |
          echo "Running linting..."
          bin/rubocop -f github

      - name: Run full test suite
        env:
          RAILS_ENV: test
          DATABASE_URL: postgres://postgres:postgres@localhost:5432/roadtrip_planner_test
          PGHOST: localhost
          PGPORT: 5432
          PGUSER: postgres
          PGPASSWORD: postgres
          PGDATABASE: roadtrip_planner_test
        run: |
          echo "Running complete test suite..."
          bundle exec rspec --format progress
          
          echo "‚úÖ All tests passed!"

      # Note: Test results are shown in the job output above

      - name: Test summary
        run: |
          echo "‚úÖ All tests completed successfully!"
          echo "üîç Security scans passed"
          echo "üìè Code quality checks passed"
          echo "üß™ Test suite passed"

  # Job 3: Calculate next semantic version based on git tags (only after tests pass)
  calculate-version:
    needs: [build, test]
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.semver.outputs.tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0  # Fetch all history for tags

      - name: Calculate semantic version
        id: semver
        run: |
          # Get the latest tag, default to v0.0.0 if no tags exist
          LATEST_TAG=$(git tag --list --sort=-version:refname | head -n1 || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"
          
          # Remove 'v' prefix for calculation
          VERSION=${LATEST_TAG#v}
          
          # Split version into components
          IFS='.' read -ra VERSION_PARTS <<< "$VERSION"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}
          
          # Increment version based on input
          case "${{ github.event.inputs.version_increment }}" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          # Create new tag with v prefix
          NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
          echo "New tag: $NEW_TAG"
          
          # Set output for other jobs
          echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT

  # Job 4: Tag and push the Docker image with calculated version
  push:
    needs: [build, test, calculate-version]
    runs-on: ubuntu-latest
    if: success()  # Only run if all previous jobs succeeded
    steps:
      - name: Download Docker image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image-candidate
          path: /tmp

      - name: Load and retag Docker image
        run: |
          # Load the untagged image
          docker load --input /tmp/docker-image-untagged.tar
          
          # Tag the image with the calculated version (with v prefix only)
          docker tag roadtrip-planner:build-candidate ${{ env.DOCKER_REPOSITORY }}:${{ needs.calculate-version.outputs.tag }}
          
          echo "üè∑Ô∏è  Tagged Docker image with version: ${{ needs.calculate-version.outputs.tag }}"

      - name: Debug repository configuration
        run: |
          echo "üîç Docker configuration debug info:"
          echo "  - DOCKER_REPOSITORY: ${{ env.DOCKER_REPOSITORY }}"
          echo "  - GitHub repo name: ${{ github.event.repository.name }}"
          echo "  - Username: ${{ secrets.DOCKER_HUB_USERNAME }}"
          echo "  - Repository variable: ${{ vars.DOCKER_HUB_REPOSITORY }}"
          
          echo "üè∑Ô∏è  Image to be pushed:"
          echo "  - ${{ env.DOCKER_REPOSITORY }}:${{ needs.calculate-version.outputs.tag }}"

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Verify login and push Docker image
        run: |
          echo "‚úÖ Successfully logged into Docker Hub"
          
          # List local images to verify they exist
          echo "üìã Local Docker images:"
          docker images | grep -E "(roadtrip|${{ env.DOCKER_REPOSITORY }})" || echo "No matching images found"
          
          # Push the version tag
          echo "üöÄ Pushing version tag: ${{ needs.calculate-version.outputs.tag }}"
          docker push ${{ env.DOCKER_REPOSITORY }}:${{ needs.calculate-version.outputs.tag }}
          
          echo "‚úÖ Successfully pushed image to Docker Hub:"
          echo "  - ${{ env.DOCKER_REPOSITORY }}:${{ needs.calculate-version.outputs.tag }}"

      - name: Push summary
        run: |
          echo "üöÄ Docker image pushed successfully!"
          echo "üè∑Ô∏è  Tag: ${{ needs.calculate-version.outputs.tag }}"
          echo "üê≥ Image available at:"
          echo "  - ${{ env.DOCKER_REPOSITORY }}:${{ needs.calculate-version.outputs.tag }}"

  # Job 5: Create git tag only after successful Docker push
  tag:
    needs: [calculate-version, push]
    runs-on: ubuntu-latest
    if: success()  # Only run if push job succeeded
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Create GitHub release tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Create and push the new tag
          git tag ${{ needs.calculate-version.outputs.tag }}
          git push origin ${{ needs.calculate-version.outputs.tag }}
          
          echo "üè∑Ô∏è  Created and pushed git tag: ${{ needs.calculate-version.outputs.tag }}"

      - name: Deployment summary
        run: |
          echo "üéâ Production deployment completed!"
          echo "üè∑Ô∏è  Git Tag: ${{ needs.calculate-version.outputs.tag }}"
          echo "üê≥ Docker Image:"
          echo "  - ${{ env.DOCKER_REPOSITORY }}:${{ needs.calculate-version.outputs.tag }}"
          echo ""
          echo "üöÄ Ready for production deployment!"